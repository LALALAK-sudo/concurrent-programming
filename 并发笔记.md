# 1.概览



- 线程安全问题，需要你接触过 Java Web 开发、Jdbc 开发、Web 服务器、分布式框架时才会遇到 
- 基于 JDK 8，最好对函数式编程、lambda 有一定了解 
- 采用了 slf4j 打印日志，这是好的实践 
- 采用了 lombok 简化 java bean 编写 
- 给每个线程好名字，这也是一项好的实践



pom.xml 依赖如下

```xml
<properties>
 <maven.compiler.source>1.8</maven.compiler.source>
 <maven.compiler.target>1.8</maven.compiler.target>
</properties>
<dependencies>
     <dependency>
         <groupId>org.projectlombok</groupId>
         <artifactId>lombok</artifactId>
         <version>1.18.10</version>
 	 </dependency>
     <dependency>
         <groupId>ch.qos.logback</groupId>
         <artifactId>logback-classic</artifactId>
         <version>1.2.3</version>
     </dependency>
</dependencies>

```

logback.xml 配置如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration
         xmlns="http://ch.qos.logback/xml/ns/logback"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://ch.qos.logback/xml/ns/logback logback.xsd">
     <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
         <encoder>
         <pattern>%date{HH:mm:ss} [%t] %logger - %m%n</pattern>
         </encoder>
     </appender>
     <logger name="c" level="debug" additivity="false">
         <appender-ref ref="STDOUT"/>
     </logger>
     <root level="ERROR">
         <appender-ref ref="STDOUT"/>
     </root>
</configuration>

```



![image-20210519102230949](D:\h后端\imgs\image-20210519102230949.png)

![image-20210519102238518](D:\h后端\imgs\image-20210519102238518.png)





# 2.进程和线程

## 2.1进程与线程

### 进程

- 程序由指令和数据组成，但是这些指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令管理内存管理IO的
- 当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程
- 进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）

### 线程

- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行
- Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作
  为线程的容器（这里感觉要学了计算机组成原理之后会更有感觉吧！）

### 二者对比

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集

- 进程拥有共享的资源，如内存空间等，供其内部的线程共享

- 进程间通信较为复杂

  * 同一台计算机的进程通信称为 IPC（Inter-process communication）

  * 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP

- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量

- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低



## 2.2 并行与并发

### 并发

在单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows
下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感
觉是同时运行的 。一般会将这种线程轮流使用 CPU 的做法称为并发（concurrent）

![1583408729416](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200305194534-433138.png)

### 并行

多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。

![1583408812725](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200305194655-483025.png)

### 二者对比

引用 Rob Pike 的一段描述：

* 并发（concurrent）是同一时间应对（dealing with）多件事情的能力，
* 并行（parallel）是同一时间动手做（doing）多件事情的能力



例子

- 家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发
- 雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行
- 家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一
  个人用锅时，另一个人就得等待）


### 应用

#### 同步和异步的概念

<span style ="color:red">以调用方的角度讲</span>，如果需要等待结果返回才能继续运行的话就是同步，如果不需要等待就是异步

#### 1) 设计

多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。

#### 2) 结论

- 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程
- tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程
- ui 程序中，开线程进行其他操作，避免阻塞 ui 线程



# 3.java线程

## 3.1 创建和运行线程

### （1）继承Thread类

​	Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己创建的类型直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。

优点：代码简单

缺点：该类无法继承别的类



```java
public class threadTest {
    public static void main(String[] args) {
        ThreadDemo t1 = new ThreadDemo();
        t1.setName("线程1");
        t1.start();

        ThreadDemo t2 = new ThreadDemo();
        t2.setName("线程2");
        t2.start();
    }
}
class ThreadDemo extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName()+"计数"+i);
        }
    }
}
```



### （2）实现Runnable接口

java中的类属于单继承（防止菱形继承），如果自己的类以及extends另一个类，就无法直接extends Thread， 但是一个类继承一个类同时，是可以实现多个接口的。

优点：继承其他类。统一实现该接口的实例可以共享资源。

缺点：代码复杂。



```java
public class ThreadDemo2 {
    public static void main(String[] args) {
        ThreadTest1 t = new ThreadTest1();
        Thread t1 = new Thread(t,"线程1");
        t1.start();

        Thread t2 = new Thread(t,"线程2");
        t2.start();
    }


}
class ThreadTest1 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}
```



### （3）实现callable接口

实现Runnable和实现Callable接口的方式基本相同，不过**Calble接口中的call（）方法有返回值，Runnable接口中的run（）方法无返回值**



```java
public class TestCallable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable<Object> objectCallable = new Ticket<Object>();
        FutureTask<Object> objectFutureTask = new FutureTask<Object>(objectCallable);
        Thread t1 = new Thread(objectFutureTask,"线程1");
        t1.start();
        System.out.println(objectFutureTask.get());
    }
}

class Ticket<String> implements Callable<Object> {
    @Override
    public Object call() throws Exception {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
        return Thread.currentThread().getName()+"执行完毕";
    }
}

```



### （4）线程池方式

#### 线程池的相关参数


**corePoolSize（核心线程数）**

```
（1）核心线程会一直存在，即使没有任务执行； 

（2）当线程数小于核心线程数的时候，即使有空闲线程，也会一直创建线程直到达到核心线程数；

（3）设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭。
```

**queueCapacity（任务队列容量）**

```
也叫阻塞队列，当核心线程都在运行，此时再有任务进来，会进入任务队列，排队等待线程执行。
```

**maxPoolSize（最大线程数）**

```
(1）线程池里允许存在的最大线程数量；
(2）当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务；
(3）线程池里允许存在的最大线程数量。当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务。
```

**keepAliveTime（线程空闲时间）**

```
(1）当线程空闲时间达到keepAliveTime时，线程会退出（关闭），直到线程数等于核心线程数；
(2）如果设置了allowCoreThreadTimeout=true，则线程会退出直到线程数等于零。
```

**allowCoreThreadTimeout（允许核心线程超时）**

**rejectedExecutionHandler（任务拒绝处理器）**

```
(1）当线程数量达到最大线程数，且任务队列已满时，会拒绝任务；
(2）调用线程池shutdown()方法后，会等待执行完线程池的任务之后，再shutdown()。如果在调用了shutdown()方法和线程池真正shutdown()之间提交任务，会拒绝新任务。
```



```java
public class ThreadPoolDemo {
    public static void main(String[] args) {
        // 创建线程池对象
        ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象
        // 创建Runnable实例对象
        MyRunnable r = new MyRunnable();

        //自己创建线程对象的方式
        // Thread t = new Thread(r);
        // t.start(); ---> 调用MyRunnable中的run()

        // 从线程池中获取线程对象,然后调用MyRunnable中的run()
        service.submit(r);
        // 再获取个线程对象，调用MyRunnable中的run()
        service.submit(r);
        service.submit(r);
        // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。
        // 将使用完的线程又归还到了线程池中
        // 关闭线程池
        //service.shutdown();
    }
}
```



#### 线程池工作流程

一个新的任务到线程池时，线程池的处理流程如下：

1.**线程池判断核心线程池里的线程是否都在执行任务**。 如果不是，创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。

2.线程池判断阻塞队列是否已满。 如果阻塞队列没有满，则将新提交的任务存储在阻塞队列中。如果阻塞队列已满，则进入下个流程。

3.线程池判断线程池里的线程是否都处于工作状态。 如果没有，则创建一个新的工作线程来执行任务。如果已满，则交给饱和策略来处理这个任务。

4.饱和策略，**当提交的任务数大于（workQueue.size() + maximumPoolSize ），就会触发线程池的拒绝策略**

![在这里插入图片描述](D:\h后端\imgs\20190722201421710.png)

线程池的核心实现类是`ThreadPoolExecutor类`，用来执行提交的任务。因此，任务提交到线程池时，具体的处理流程是由`ThreadPoolExecutor类`的**execute()方法**去完成的。

![在这里插入图片描述](D:\h后端\imgs\20190722202417970.png)





#### 拒绝策略

#### 1、AbortPolicy

直接抛出拒绝异常（继承自RuntimeException），会中断调用者的处理过程，所以除非有明确需求，一般不推荐

#### 2、CallerRunsPolicy

在调用者线程中（也就是说谁把 r 这个任务甩来的），运行当前被丢弃的任务。

只会用调用者所在线程来运行任务，也就是说任务不会进入线程池。

如果线程池已经被关闭，则直接丢弃该任务。

#### 3、DiscardOledestPolicy

丢弃队列中最老的，然后再次尝试提交新任务。

#### 4、DiscardPolicy

默默丢弃无法加载的任务。

这个代码就很简单了，真的是啥也没做

#### 5、通过实现 RejectedExecutionHandler 接口扩展（自定义）

jdk内置的四种拒绝策略（都在ThreadPoolExecutor.java里面）代码都很简洁易懂。

我们只要继承接口都可以根据自己需要自定义拒绝策略。下面看两个例子。

一是netty自己实现的线程池里面私有的一个拒绝策略。单独启动一个新的临时线程来执行任务。

 



### 方法一，直接使用 Thread

```java
// 构造方法的参数是给线程指定名字，，推荐给线程起个名字
Thread t1 = new Thread("t1") {
     @Override
     // run 方法内实现了要执行的任务
     public void run() {
     	log.debug("hello");
     }
};
t1.start();
```



### 方法二，使用 Runnable 配合 Thread

把【线程】和【任务】（要执行的代码）分开，Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）Test2.java

```java
// 创建任务对象
Runnable task2 = new Runnable() {
  	@Override
 	public void run() {
 		log.debug("hello");
 	}
};
// 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字
Thread t2 = new Thread(task2, "t2");
t2.start();
```

#### 小结

方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。通过查看源码可以发现，方法二其实到底还是通过方法一执行的！

### 方法三，FutureTask 配合 Thread(callable)

FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况 Test3.java

```java
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 实现多线程的第三种方法可以返回数据
        FutureTask futureTask = new FutureTask<>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                log.debug("多线程任务");
                Thread.sleep(100);
                return 100;
            }
        });
        // 主线程阻塞，同步等待 task 执行完毕的结果
        new Thread(futureTask,"我的名字").start();
        log.debug("主线程");
        log.debug("{}",futureTask.get());
    }
```

Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}

```

  Future提供了三种功能：   　　

1. 判断任务是否完成；   　　

2. 能够中断任务；   　　

3. 能够获取任务执行结果。   

[FutureTask是Future和Runable的实现](